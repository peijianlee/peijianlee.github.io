{"_path":"/posts/20231205","_dir":"posts","_draft":false,"_partial":false,"_locale":"","title":"vue 使用 docxtemplater 导出 word 文件","description":"docxtemplater 是一种邮件合并工具，以编程方式使用并处理条件、循环，并且可以扩展以插入任何内容（表格、html、图像）","navigation":{"title":"vue 使用 docxtemplater 导出 word 文件","description":"docxtemplater 是一种邮件合并工具，以编程方式使用并处理条件、循环，并且可以扩展以插入任何内容（表格、html、图像）","date":"2023-12-05 12:30:00","account":"lpj","tags":["docxtemplater","文件导出"]},"body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"docxtemplater-导出-word"},"children":[{"type":"text","value":"docxtemplater 导出 word"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"docxtemplater 是一种邮件合并工具，以编程方式使用并处理条件、循环，并且可以扩展以插入任何内容（表格、html、图像）"}]},{"type":"element","tag":"h2","props":{"id":"一安装-docxtemplater"},"children":[{"type":"text","value":"一、安装 docxtemplater"}]},{"type":"element","tag":"pre","props":{"className":["language-cmd"],"code":"// 安装 docxtemplater\nnpm install docxtemplater pizzip  --save\n// 安装 jszip-utils\nnpm install jszip-utils --save\n// 安装 FileSaver\nnpm install file-saver --save\n// 引入处理图片的插件\nnpm install docxtemplater-image-module-free --save\n//docx-preview预览插件\nnpm i docx-preview --save\n","language":"cmd","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 安装 docxtemplater\nnpm install docxtemplater pizzip  --save\n// 安装 jszip-utils\nnpm install jszip-utils --save\n// 安装 FileSaver\nnpm install file-saver --save\n// 引入处理图片的插件\nnpm install docxtemplater-image-module-free --save\n//docx-preview预览插件\nnpm i docx-preview --save\n"}]}]},{"type":"element","tag":"h2","props":{"id":"二docxtemplater-语法"},"children":[{"type":"text","value":"二、docxtemplater 语法"}]},{"type":"element","tag":"h3","props":{"id":"_1-单一变量使用-包含"},"children":[{"type":"text","value":"1.  单一变量使用  {}  包含"}]},{"type":"element","tag":"pre","props":{"className":["language-js"],"code":"{\n    name: 'lisi',\n    age: 18\n}\n","language":"js","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"{\n    name: 'lisi',\n    age: 18\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"在 word 模板文件中表示为："}]}]},{"type":"element","tag":"pre","props":{"className":["language-js"],"code":"{name}、{age}\n","language":"js","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"{name}、{age}\n"}]}]},{"type":"element","tag":"h3","props":{"id":"_2-json数组格式则包裹一个循环对象"},"children":[{"type":"text","value":"2.  json数组格式，则包裹一个循环对象："}]},{"type":"element","tag":"pre","props":{"className":["language-js"],"code":"list: [\n    {name:'lisi', class: '4-1', age:'18'},\n    {name:'wangwu', class: '4-2', age:'16'}\n]\n","language":"js","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"list: [\n    {name:'lisi', class: '4-1', age:'18'},\n    {name:'wangwu', class: '4-2', age:'16'}\n]\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"在 word 模板文件中表示为："}]}]},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{"align":"center"},"children":[{"type":"text","value":"姓名"}]},{"type":"element","tag":"th","props":{"align":"center"},"children":[{"type":"text","value":"班级"}]},{"type":"element","tag":"th","props":{"align":"center"},"children":[{"type":"text","value":"年龄"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{"align":"center"},"children":[{"type":"text","value":"内容默认居左"}]},{"type":"element","tag":"td","props":{"align":"center"},"children":[{"type":"text","value":"内容居中"}]},{"type":"element","tag":"td","props":{"align":"center"},"children":[{"type":"text","value":"内容居右"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{"align":"center"},"children":[{"type":"text","value":"{#list}{name}"}]},{"type":"element","tag":"td","props":{"align":"center"},"children":[{"type":"text","value":"{class}"}]},{"type":"element","tag":"td","props":{"align":"center"},"children":[{"type":"text","value":"{age}{/list}"}]}]}]}]},{"type":"element","tag":"h3","props":{"id":"_3-使用图片地址"},"children":[{"type":"text","value":"3.  使用图片地址："}]},{"type":"element","tag":"pre","props":{"className":["language-js"],"code":"{%imgUrl}\n","language":"js","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"{%imgUrl}\n"}]}]},{"type":"element","tag":"h3","props":{"id":"_4-如果多张图片地址时与循环列表一样-但必须换行"},"children":[{"type":"text","value":"4.  如果多张图片地址时，与循环列表一样, 但"},{"type":"element","tag":"em","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"必须换行"}]}]},{"type":"text","value":"："}]},{"type":"element","tag":"pre","props":{"className":["language-js"],"code":"{#imglist}\n    {%imgUrl}\n{/imglist} \n","language":"js","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"{#imglist}\n    {%imgUrl}\n{/imglist} \n"}]}]},{"type":"element","tag":"h2","props":{"id":"三封装js"},"children":[{"type":"text","value":"三、封装JS"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"新建 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"outputWord.js"}]},{"type":"text","value":" 文件"}]},{"type":"element","tag":"pre","props":{"className":["language-js"],"code":"/**\n * 导出word文档\n * \n// 安装 docxtemplater\nnpm install docxtemplater pizzip  --save\n// 安装 jszip-utils\nnpm install jszip-utils --save\n// 安装 FileSaver\nnpm install file-saver --save\n// 引入处理图片的插件\nnpm install docxtemplater-image-module-free --save\n//docx-preview预览插件\nnpm i docx-preview --save\n\n// 安装全部\nnpm install docxtemplater pizzip jszip-utils file-saver docxtemplater-image-module-free docx-preview --save\n */\nimport Docxtemplater from 'docxtemplater'\nimport ImageModule from 'docxtemplater-image-module-free'\nimport PizZip from 'pizzip'\nimport JSZipUtils from 'jszip-utils'\nimport { renderAsync } from 'docx-preview'\nimport { saveAs } from 'file-saver'\nimport * as echarts from 'echarts'\n\nlet imageMaxWidth = 640\nlet createdTime = ''\nlet imageSizeObjs = {}\n/**\n * 将base64格式的数据转为ArrayBuffer\n * @param {Object} dataURL base64格式的数据\n */\nfunction base64DataURLToArrayBuffer(dataURL) {\n    const base64Regex = /^data:image\\/(png|jpg|jpeg|svg|svg\\+xml);base64,/;\n    if (!base64Regex.test(dataURL)) {\n        return false\n    }\n    const stringBase64 = dataURL.replace(base64Regex, \"\")\n    let binaryString\n    if (typeof window !== \"undefined\") {\n        binaryString = window.atob(stringBase64)\n    } else {\n        binaryString = Buffer.from(stringBase64, \"base64\").toString(\"binary\")\n    }\n    const len = binaryString.length\n    const bytes = new Uint8Array(len)\n    for (let i = 0; i < len; i++) {\n        const ascii = binaryString.charCodeAt(i)\n        bytes[i] = ascii\n    }\n    return bytes.buffer\n}\n \n/**\n * 将图片的url路径转为base64路径\n * 可以用await等待Promise的异步返回\n * @param {Object} imgUrl 图片路径\n */\nexport const getBase64Sync = (imgUrl) => {\n    return new Promise((resolve, reject) => {\n        // 一定要设置为let，不然图片不显示\n        let image = new Image()\n        //图片地址\n        image.src = imgUrl\n        // 解决跨域问题\n        image.setAttribute(\"crossOrigin\", '*')  // 支持跨域图片\n        // image.onload为异步加载\n        image.onload = () => {\n            let canvas = document.createElement(\"canvas\")\n            const {width, height} = image\n            canvas.width = width\n            canvas.height = height\n            let context = canvas.getContext(\"2d\")\n            context.drawImage(image, 0, 0, width, height)\n            //图片后缀名\n            let ext = image.src.substring(image.src.lastIndexOf(\".\") + 1).toLowerCase()\n            //图片质量\n            let quality = 0.8\n            //转成base64\n            let dataurl = canvas.toDataURL(\"image/\" + ext, quality)\n            // 将缩放后的尺寸信息保存\n            let key = fomratKey(dataurl)\n            imageSizeObjs[key] = imageScaleSize(width, height)\n            // 解除引用\n            image = null\n            //返回\n            resolve(dataurl)\n        };\n    })\n}\n// 截取base64后25位，加key，作为imageSizeObjs的key值\nconst fomratKey = (base64Data) => {\n    const last25 = base64Data.substring(base64Data.length - 25)\n    return `${last25}`\n}\n\n// 缩放图片尺寸\nconst imageScaleSize = (w, h) => {\n    if (w > imageMaxWidth) {\n        const scale = imageMaxWidth / w\n        w *= scale\n        h *= scale\n        return([Math.ceil(w), Math.ceil(h)])\n    } else {\n        return([w, h])\n    }\n}\n \n/**\n * 将echart转为base64\n * 可以用await等待Promise的异步返回\n * @param {Object} imgUrl 图片路径\n */\nexport const chartToBase64Pic = (opt) => {\n    const {dom, bgColor = '#fff'} = opt || {}\n    return new Promise((resolve, reject) => {\n        if (!dom) {\n            console.warn('未传入echarts的dom')\n            resolve(null)\n        }\n        const echartDom = echarts.getInstanceByDom(dom)\n        const base64Str = echartDom.getDataURL({\n            type: 'png',\n            //导出的图片分辨率比例，默认为 1\n            pixelRatio: 1,\n            // 导出的图片背景色，默认使用 option 里的 backgroundColor\n            backgroundColor: bgColor\n        })\n        // 将缩放后的尺寸信息保存\n        let key = fomratKey(base64Str)\n        imageSizeObjs[key] = imageScaleSize(dom.offsetWidth, dom.offsetHeight)\n        resolve(base64Str)\n    })\n}\n\n// 获取年月日时分秒\nconst getDate = () => {\n    const now = new Date()\n    const year = now.getFullYear()\n    const month = (now.getMonth() + 1).toString().padStart(2, '0')\n    const day = now.getDate().toString().padStart(2, '0')\n    const hour = now.getHours().toString().padStart(2, '0')\n    const minute = now.getMinutes().toString().padStart(2, '0')\n    const second = now.getSeconds().toString().padStart(2, '0')\n    return [\n        `${year}-${month}-${day} ${hour}:${minute}:${second}`,\n        `${year}年${month}月${day}日${hour}时${minute}分${second}秒`,\n        `${year}-${month}-${day}`,\n        `${year}年${month}月${day}日`\n    ]\n}\n\n/** \n * 递归所有数据，并对图片处理，返回新的对象\n * 避免污染原数据\n */\nconst deepCopyAndHandleBase64 = async (obj) => {\n    if (obj === null || typeof obj !== 'object') {\n        return obj\n    }\n    let copy = Array.isArray(obj)? [] : {}\n    for (let key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            const val = obj[key]\n            if (val instanceof Element) {\n                // 将 echart dom 的对象转成base64\n                copy[key] = await chartToBase64Pic({dom: val})\n            } else if (typeof(val) === 'string' && val.indexOf('http') !== -1) {\n                // 将http的图片转成base64\n                copy[key] = await getBase64Sync(val)\n            } else {\n                copy[key] = await deepCopyAndHandleBase64(obj[key])\n            }\n        }\n    }\n    return copy\n}\n\n/**\n * 渲染文档\n * @param {Object} outputWordData 必填，要导出的数据列表\n * @param {Object} fileConfigInfo 选填，配置文件，内容包括\n *     @param {String} templateDocxPath 必填，模板路径\n *     @param {String} imgMaxWidth 选填，图片的最大宽度，超过按比例缩放\n *     @param {String} placeInfo 选填，页面的信息,会混入 outputWordData\n */\nexport const ExportBriefDataDocx = async (outputWordData, fileConfigInfo) => {\n    imageSizeObjs = {}\n\n    const {imgMaxWidth, placeInfo = {}, templateDocxPath} = fileConfigInfo || {}\n    // 如果有传入 imgMaxWidth \n    if (imgMaxWidth) imageMaxWidth = imgMaxWidth\n    let outData = await deepCopyAndHandleBase64(outputWordData)\n    outData = Object.assign(outData, placeInfo)\n\n    // 如果没有createdTime的对象，就创建当前时间\n    const [fullDate, fullDateCn, date, dateCn] = getDate()\n    if (!outData.createdTime) {\n        outData.createdTime = fullDate\n        createdTime = fullDate\n    } else {\n        createdTime = outData.createdTime\n    }\n    outData.fullDateCn = fullDateCn\n    outData.dateCn = dateCn\n    return new Promise((resolve) => {\n        //这里要引入处理图片的插件\n        JSZipUtils.getBinaryContent(templateDocxPath, (error, content) => {\n            if (error) {\n                console.log(error)\n            }\n        \n            let imageOpts = {\n                //图像是否居中\n                centered: true,\n                //将base64的数据转为ArrayBuffer\n                getImage: (chartId) => {\n                    return base64DataURLToArrayBuffer(chartId)\n                },\n                getSize: (img, tagValue, tagName) => {\n                    const key = fomratKey(tagValue)\n                    return imageSizeObjs[key] || []\n                }\n            }\n\n            // 创建一个JSZip实例，内容为模板的内容        \n            const zip = new PizZip(content)\n            // 创建并加载 Docxtemplater 实例对象\n            // 设置模板变量的值\n            let doc = new Docxtemplater()\n            doc.attachModule(new ImageModule(imageOpts))\n            doc.loadZip(zip)\n            doc.setData(outData)\n            try {\n                // 呈现文档，会将内部所有变量替换成值，\n                doc.render()\n            } catch (error) {\n                const e = {\n                    message: error.message,\n                    name: error.name,\n                    stack: error.stack,\n                    properties: error.properties\n                }\n                console.log('err',{ error: e })\n                // 当使用json记录时，此处抛出错误信息\n                throw error\n            }\n            // 生成一个代表Docxtemplater对象的zip文件（不是一个真实的文件，而是在内存中的表示）\n            const out = doc.getZip().generate({\n                type: 'blob',\n                mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\n            })\n            resolve(out)\n        })\n    })\n}\nexport const ViewWordFile = (out, dom) => {\n    dom\n        ? renderAsync(out, dom)\n        : console.warn('dom 未定义')\n}\n\nexport const DownWordFile = (out, outFileName) => {\n    outFileName\n        ? saveAs(out, `${outFileName}(${createdTime})`)\n        : console.warn('outFileName 未定义')\n} \n\n","language":"js","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"/**\n * 导出word文档\n * \n// 安装 docxtemplater\nnpm install docxtemplater pizzip  --save\n// 安装 jszip-utils\nnpm install jszip-utils --save\n// 安装 FileSaver\nnpm install file-saver --save\n// 引入处理图片的插件\nnpm install docxtemplater-image-module-free --save\n//docx-preview预览插件\nnpm i docx-preview --save\n\n// 安装全部\nnpm install docxtemplater pizzip jszip-utils file-saver docxtemplater-image-module-free docx-preview --save\n */\nimport Docxtemplater from 'docxtemplater'\nimport ImageModule from 'docxtemplater-image-module-free'\nimport PizZip from 'pizzip'\nimport JSZipUtils from 'jszip-utils'\nimport { renderAsync } from 'docx-preview'\nimport { saveAs } from 'file-saver'\nimport * as echarts from 'echarts'\n\nlet imageMaxWidth = 640\nlet createdTime = ''\nlet imageSizeObjs = {}\n/**\n * 将base64格式的数据转为ArrayBuffer\n * @param {Object} dataURL base64格式的数据\n */\nfunction base64DataURLToArrayBuffer(dataURL) {\n    const base64Regex = /^data:image\\/(png|jpg|jpeg|svg|svg\\+xml);base64,/;\n    if (!base64Regex.test(dataURL)) {\n        return false\n    }\n    const stringBase64 = dataURL.replace(base64Regex, \"\")\n    let binaryString\n    if (typeof window !== \"undefined\") {\n        binaryString = window.atob(stringBase64)\n    } else {\n        binaryString = Buffer.from(stringBase64, \"base64\").toString(\"binary\")\n    }\n    const len = binaryString.length\n    const bytes = new Uint8Array(len)\n    for (let i = 0; i < len; i++) {\n        const ascii = binaryString.charCodeAt(i)\n        bytes[i] = ascii\n    }\n    return bytes.buffer\n}\n \n/**\n * 将图片的url路径转为base64路径\n * 可以用await等待Promise的异步返回\n * @param {Object} imgUrl 图片路径\n */\nexport const getBase64Sync = (imgUrl) => {\n    return new Promise((resolve, reject) => {\n        // 一定要设置为let，不然图片不显示\n        let image = new Image()\n        //图片地址\n        image.src = imgUrl\n        // 解决跨域问题\n        image.setAttribute(\"crossOrigin\", '*')  // 支持跨域图片\n        // image.onload为异步加载\n        image.onload = () => {\n            let canvas = document.createElement(\"canvas\")\n            const {width, height} = image\n            canvas.width = width\n            canvas.height = height\n            let context = canvas.getContext(\"2d\")\n            context.drawImage(image, 0, 0, width, height)\n            //图片后缀名\n            let ext = image.src.substring(image.src.lastIndexOf(\".\") + 1).toLowerCase()\n            //图片质量\n            let quality = 0.8\n            //转成base64\n            let dataurl = canvas.toDataURL(\"image/\" + ext, quality)\n            // 将缩放后的尺寸信息保存\n            let key = fomratKey(dataurl)\n            imageSizeObjs[key] = imageScaleSize(width, height)\n            // 解除引用\n            image = null\n            //返回\n            resolve(dataurl)\n        };\n    })\n}\n// 截取base64后25位，加key，作为imageSizeObjs的key值\nconst fomratKey = (base64Data) => {\n    const last25 = base64Data.substring(base64Data.length - 25)\n    return `${last25}`\n}\n\n// 缩放图片尺寸\nconst imageScaleSize = (w, h) => {\n    if (w > imageMaxWidth) {\n        const scale = imageMaxWidth / w\n        w *= scale\n        h *= scale\n        return([Math.ceil(w), Math.ceil(h)])\n    } else {\n        return([w, h])\n    }\n}\n \n/**\n * 将echart转为base64\n * 可以用await等待Promise的异步返回\n * @param {Object} imgUrl 图片路径\n */\nexport const chartToBase64Pic = (opt) => {\n    const {dom, bgColor = '#fff'} = opt || {}\n    return new Promise((resolve, reject) => {\n        if (!dom) {\n            console.warn('未传入echarts的dom')\n            resolve(null)\n        }\n        const echartDom = echarts.getInstanceByDom(dom)\n        const base64Str = echartDom.getDataURL({\n            type: 'png',\n            //导出的图片分辨率比例，默认为 1\n            pixelRatio: 1,\n            // 导出的图片背景色，默认使用 option 里的 backgroundColor\n            backgroundColor: bgColor\n        })\n        // 将缩放后的尺寸信息保存\n        let key = fomratKey(base64Str)\n        imageSizeObjs[key] = imageScaleSize(dom.offsetWidth, dom.offsetHeight)\n        resolve(base64Str)\n    })\n}\n\n// 获取年月日时分秒\nconst getDate = () => {\n    const now = new Date()\n    const year = now.getFullYear()\n    const month = (now.getMonth() + 1).toString().padStart(2, '0')\n    const day = now.getDate().toString().padStart(2, '0')\n    const hour = now.getHours().toString().padStart(2, '0')\n    const minute = now.getMinutes().toString().padStart(2, '0')\n    const second = now.getSeconds().toString().padStart(2, '0')\n    return [\n        `${year}-${month}-${day} ${hour}:${minute}:${second}`,\n        `${year}年${month}月${day}日${hour}时${minute}分${second}秒`,\n        `${year}-${month}-${day}`,\n        `${year}年${month}月${day}日`\n    ]\n}\n\n/** \n * 递归所有数据，并对图片处理，返回新的对象\n * 避免污染原数据\n */\nconst deepCopyAndHandleBase64 = async (obj) => {\n    if (obj === null || typeof obj !== 'object') {\n        return obj\n    }\n    let copy = Array.isArray(obj)? [] : {}\n    for (let key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            const val = obj[key]\n            if (val instanceof Element) {\n                // 将 echart dom 的对象转成base64\n                copy[key] = await chartToBase64Pic({dom: val})\n            } else if (typeof(val) === 'string' && val.indexOf('http') !== -1) {\n                // 将http的图片转成base64\n                copy[key] = await getBase64Sync(val)\n            } else {\n                copy[key] = await deepCopyAndHandleBase64(obj[key])\n            }\n        }\n    }\n    return copy\n}\n\n/**\n * 渲染文档\n * @param {Object} outputWordData 必填，要导出的数据列表\n * @param {Object} fileConfigInfo 选填，配置文件，内容包括\n *     @param {String} templateDocxPath 必填，模板路径\n *     @param {String} imgMaxWidth 选填，图片的最大宽度，超过按比例缩放\n *     @param {String} placeInfo 选填，页面的信息,会混入 outputWordData\n */\nexport const ExportBriefDataDocx = async (outputWordData, fileConfigInfo) => {\n    imageSizeObjs = {}\n\n    const {imgMaxWidth, placeInfo = {}, templateDocxPath} = fileConfigInfo || {}\n    // 如果有传入 imgMaxWidth \n    if (imgMaxWidth) imageMaxWidth = imgMaxWidth\n    let outData = await deepCopyAndHandleBase64(outputWordData)\n    outData = Object.assign(outData, placeInfo)\n\n    // 如果没有createdTime的对象，就创建当前时间\n    const [fullDate, fullDateCn, date, dateCn] = getDate()\n    if (!outData.createdTime) {\n        outData.createdTime = fullDate\n        createdTime = fullDate\n    } else {\n        createdTime = outData.createdTime\n    }\n    outData.fullDateCn = fullDateCn\n    outData.dateCn = dateCn\n    return new Promise((resolve) => {\n        //这里要引入处理图片的插件\n        JSZipUtils.getBinaryContent(templateDocxPath, (error, content) => {\n            if (error) {\n                console.log(error)\n            }\n        \n            let imageOpts = {\n                //图像是否居中\n                centered: true,\n                //将base64的数据转为ArrayBuffer\n                getImage: (chartId) => {\n                    return base64DataURLToArrayBuffer(chartId)\n                },\n                getSize: (img, tagValue, tagName) => {\n                    const key = fomratKey(tagValue)\n                    return imageSizeObjs[key] || []\n                }\n            }\n\n            // 创建一个JSZip实例，内容为模板的内容        \n            const zip = new PizZip(content)\n            // 创建并加载 Docxtemplater 实例对象\n            // 设置模板变量的值\n            let doc = new Docxtemplater()\n            doc.attachModule(new ImageModule(imageOpts))\n            doc.loadZip(zip)\n            doc.setData(outData)\n            try {\n                // 呈现文档，会将内部所有变量替换成值，\n                doc.render()\n            } catch (error) {\n                const e = {\n                    message: error.message,\n                    name: error.name,\n                    stack: error.stack,\n                    properties: error.properties\n                }\n                console.log('err',{ error: e })\n                // 当使用json记录时，此处抛出错误信息\n                throw error\n            }\n            // 生成一个代表Docxtemplater对象的zip文件（不是一个真实的文件，而是在内存中的表示）\n            const out = doc.getZip().generate({\n                type: 'blob',\n                mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\n            })\n            resolve(out)\n        })\n    })\n}\nexport const ViewWordFile = (out, dom) => {\n    dom\n        ? renderAsync(out, dom)\n        : console.warn('dom 未定义')\n}\n\nexport const DownWordFile = (out, outFileName) => {\n    outFileName\n        ? saveAs(out, `${outFileName}(${createdTime})`)\n        : console.warn('outFileName 未定义')\n} \n\n"}]}]},{"type":"element","tag":"h2","props":{"id":"四封装vue组件"},"children":[{"type":"text","value":"四、封装vue组件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"新建 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"outputWord.vue"}]},{"type":"text","value":" 文件"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"例子使用 elementUI，可以删除相关代码"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"例子是支持 echart 图形导出，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"需要引入 echart"}]}]}]},{"type":"element","tag":"pre","props":{"className":["language-js"],"code":"/*\n    Component: outputWord\n*/\n<template>\n    <div class=\"outputWord\" style=\"display:inline-block;\">\n        <el-button :size=\"size\" type=\"success\" icon=\"el-icon-download\" @click=\"exportWordFile\" >\n            {{title}}\n        </el-button>\n        <el-dialog\n            fullscreen\n            append-to-body\n            title=\"生成智能报告\"\n            :visible.sync=\"dialogVisible\">\n            <div ref=\"dailyContent\" style=\"height:calc(100vh - 155px); overflow: auto;\"></div>\n            <span slot=\"footer\" class=\"dialog-footer\">\n                <el-button type=\"success\" icon=\"el-icon-download\" @click=\"download\">导出</el-button>\n                <el-button @click=\"dialogVisible = false\">关闭</el-button>\n            </span>\n        </el-dialog>\n    </div>\n</template>\n\n<script>\nimport {\n    ExportBriefDataDocx,\n    ViewWordFile,\n    DownWordFile\n} from '@/utils/methods/outputWord/outputWord.js'\n\n\nexport default {\n    props: {\n        title: {\n            default: '导出预览'\n        },\n        templateName: {\n            default: ''\n        },\n        outputWordData: {\n            type: Object,\n            default: () => null\n        },\n        outFileName: {\n            type: String,\n            default: '未定义'\n        },\n        size: {\n            type: String,\n            default: ''\n        }\n    },\n    data () {\n        return {\n            docx: null,\n            dialogVisible: false,\n            fileConfig: {\n                agjlxtj: {\n                    outFileName: \"测试word文档\",\n                    templateDocxPath: \"/测试word文档.docx\",\n                    imgMaxWidth: 750,\n                    placeInfo: {\n                        headerTitle: \"信息科技有限公司\",\n                        headerSubTitle: \"信息科技有限公司\"\n                    }\n                }\n            }\n        }   \n    },\n    mounted () {\n    },\n    methods:{\n        async exportWordFile (){\n            const fileConfigInfo = this.fileConfig[this.templateName]\n            this.docx = null\n            this.dialogVisible = true\n            this.docx = await ExportBriefDataDocx(this.outputWordData, fileConfigInfo)\n            ViewWordFile(this.docx, this.$refs.dailyContent)\n        },\n        download () {\n            DownWordFile(this.docx, this.outFileName)\n        }\n    }\n}\n</script>\n<style scoped lang=\"stylus\" rel=\"stylesheet/stylus\">\n>>> .el-dialog .el-dialog__body\n    padding 0\n</style>\n","language":"js","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"/*\n    Component: outputWord\n*/\n<template>\n    <div class=\"outputWord\" style=\"display:inline-block;\">\n        <el-button :size=\"size\" type=\"success\" icon=\"el-icon-download\" @click=\"exportWordFile\" >\n            {{title}}\n        </el-button>\n        <el-dialog\n            fullscreen\n            append-to-body\n            title=\"生成智能报告\"\n            :visible.sync=\"dialogVisible\">\n            <div ref=\"dailyContent\" style=\"height:calc(100vh - 155px); overflow: auto;\"></div>\n            <span slot=\"footer\" class=\"dialog-footer\">\n                <el-button type=\"success\" icon=\"el-icon-download\" @click=\"download\">导出</el-button>\n                <el-button @click=\"dialogVisible = false\">关闭</el-button>\n            </span>\n        </el-dialog>\n    </div>\n</template>\n\n<script>\nimport {\n    ExportBriefDataDocx,\n    ViewWordFile,\n    DownWordFile\n} from '@/utils/methods/outputWord/outputWord.js'\n\n\nexport default {\n    props: {\n        title: {\n            default: '导出预览'\n        },\n        templateName: {\n            default: ''\n        },\n        outputWordData: {\n            type: Object,\n            default: () => null\n        },\n        outFileName: {\n            type: String,\n            default: '未定义'\n        },\n        size: {\n            type: String,\n            default: ''\n        }\n    },\n    data () {\n        return {\n            docx: null,\n            dialogVisible: false,\n            fileConfig: {\n                agjlxtj: {\n                    outFileName: \"测试word文档\",\n                    templateDocxPath: \"/测试word文档.docx\",\n                    imgMaxWidth: 750,\n                    placeInfo: {\n                        headerTitle: \"信息科技有限公司\",\n                        headerSubTitle: \"信息科技有限公司\"\n                    }\n                }\n            }\n        }   \n    },\n    mounted () {\n    },\n    methods:{\n        async exportWordFile (){\n            const fileConfigInfo = this.fileConfig[this.templateName]\n            this.docx = null\n            this.dialogVisible = true\n            this.docx = await ExportBriefDataDocx(this.outputWordData, fileConfigInfo)\n            ViewWordFile(this.docx, this.$refs.dailyContent)\n        },\n        download () {\n            DownWordFile(this.docx, this.outFileName)\n        }\n    }\n}\n</script>\n<style scoped lang=\"stylus\" rel=\"stylesheet/stylus\">\n>>> .el-dialog .el-dialog__body\n    padding 0\n</style>\n"}]}]},{"type":"element","tag":"h2","props":{"id":"五调用方法"},"children":[{"type":"text","value":"五、调用方法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"新建 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"index.vue"}]},{"type":"text","value":" 文件"}]},{"type":"element","tag":"pre","props":{"className":["language-js"],"code":"/*\n    Component: index\n*/\n<template>\n    <div class=\"index\">\n        <outputWord\n            title=\"生成报表\"\n            outFileName=\"测试统计报表\"\n            templateName=\"agjlxtj\"\n            :outputWordData=\"outputWordData\"\n        />\n        <el-button style=\"margin-left: 10px;\" @click=\"getDataList\">生成数据</el-button>\n        <el-table :data=\"outputWordData.list\" border style=\"width: 100%\">\n            <el-table-column prop=\"name\" label=\"名称\" />\n            <el-table-column prop=\"value\" label=\"数量\" />\n        </el-table>\n        <div ref=\"pieChart\" style=\"width: 500px; height: 500px;\"></div>\n    </div>\n</template>\n\n<script>\nimport * as echarts from 'echarts'\nimport outputWord from \"@/utils/methods/outputWord/outputWord.vue\"\nexport default {\n    name: \"index\",\n    components: {\n        outputWord\n    },\n    props: {},\n    data () {\n        return {\n            outputWordData: {\n                title: '测试word文档',\n                subtitle1: '统计列表',\n                subtitle2: '占比统计',\n                list: [],\n                imglist:[\n                    {\n                        imgUrl: \"https://t7.baidu.com/it/u=4198287529,2774471735&fm=193&f=GIF\"\n                    },\n                    {\n                        imgUrl: \"https://t7.baidu.com/it/u=2621658848,3952322712&fm=193&f=GIF\"\n                    }\n                ],\n                echartBase64: ''\n            }\n        }\n    },\n    mounted() {\n        this.pieChartRef = echarts.init(this.$refs.pieChart)\n        // 将要导出图形的dom赋值\n        this.outputWordData.echartBase64 = this.$refs.pieChart\n        this.getDataList()\n    },\n    methods: {\n        random (limit = 1001) {\n            return Math.floor(Math.random() * limit)\n        },\n        getDataList () {\n            const length = this.random(10) + 5\n            const list = []\n            for(let i = 0; i < length; i++) {\n                const index = i + 1\n                list.push({\n                    index, name: `person-${index}`, value: this.random()\n                })\n            }\n            this.outputWordData.list = list\n        this.drawPicChart(list)\n        },\n        drawPicChart (data) {\n            const option = {\n                tooltip: {\n                    trigger: 'item'\n                },\n                legend: {\n                    top: '5%',\n                    left: 'center'\n                },\n                series: [\n                    {\n                        name: 'Access From',\n                        type: 'pie',\n                        radius: ['40%', '70%'],\n                        avoidLabelOverlap: false,\n                        itemStyle: {\n                            borderRadius: 10,\n                            borderColor: '#fff',\n                            borderWidth: 2\n                        },\n                        label: {\n                            show: false,\n                            position: 'center'\n                        },\n                        labelLine: {\n                            show: false\n                        },\n                        data\n                    }\n                ]\n            }\n            this.pieChartRef.setOption(option)\n        }\n    }\n}\n\n</script>\n<style scoped lang=\"stylus\" rel=\"stylesheet/stylus\">\n.index\n    padding 10px\n</style>\n","language":"js","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"/*\n    Component: index\n*/\n<template>\n    <div class=\"index\">\n        <outputWord\n            title=\"生成报表\"\n            outFileName=\"测试统计报表\"\n            templateName=\"agjlxtj\"\n            :outputWordData=\"outputWordData\"\n        />\n        <el-button style=\"margin-left: 10px;\" @click=\"getDataList\">生成数据</el-button>\n        <el-table :data=\"outputWordData.list\" border style=\"width: 100%\">\n            <el-table-column prop=\"name\" label=\"名称\" />\n            <el-table-column prop=\"value\" label=\"数量\" />\n        </el-table>\n        <div ref=\"pieChart\" style=\"width: 500px; height: 500px;\"></div>\n    </div>\n</template>\n\n<script>\nimport * as echarts from 'echarts'\nimport outputWord from \"@/utils/methods/outputWord/outputWord.vue\"\nexport default {\n    name: \"index\",\n    components: {\n        outputWord\n    },\n    props: {},\n    data () {\n        return {\n            outputWordData: {\n                title: '测试word文档',\n                subtitle1: '统计列表',\n                subtitle2: '占比统计',\n                list: [],\n                imglist:[\n                    {\n                        imgUrl: \"https://t7.baidu.com/it/u=4198287529,2774471735&fm=193&f=GIF\"\n                    },\n                    {\n                        imgUrl: \"https://t7.baidu.com/it/u=2621658848,3952322712&fm=193&f=GIF\"\n                    }\n                ],\n                echartBase64: ''\n            }\n        }\n    },\n    mounted() {\n        this.pieChartRef = echarts.init(this.$refs.pieChart)\n        // 将要导出图形的dom赋值\n        this.outputWordData.echartBase64 = this.$refs.pieChart\n        this.getDataList()\n    },\n    methods: {\n        random (limit = 1001) {\n            return Math.floor(Math.random() * limit)\n        },\n        getDataList () {\n            const length = this.random(10) + 5\n            const list = []\n            for(let i = 0; i < length; i++) {\n                const index = i + 1\n                list.push({\n                    index, name: `person-${index}`, value: this.random()\n                })\n            }\n            this.outputWordData.list = list\n        this.drawPicChart(list)\n        },\n        drawPicChart (data) {\n            const option = {\n                tooltip: {\n                    trigger: 'item'\n                },\n                legend: {\n                    top: '5%',\n                    left: 'center'\n                },\n                series: [\n                    {\n                        name: 'Access From',\n                        type: 'pie',\n                        radius: ['40%', '70%'],\n                        avoidLabelOverlap: false,\n                        itemStyle: {\n                            borderRadius: 10,\n                            borderColor: '#fff',\n                            borderWidth: 2\n                        },\n                        label: {\n                            show: false,\n                            position: 'center'\n                        },\n                        labelLine: {\n                            show: false\n                        },\n                        data\n                    }\n                ]\n            }\n            this.pieChartRef.setOption(option)\n        }\n    }\n}\n\n</script>\n<style scoped lang=\"stylus\" rel=\"stylesheet/stylus\">\n.index\n    padding 10px\n</style>\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"一安装-docxtemplater","depth":2,"text":"一、安装 docxtemplater"},{"id":"二docxtemplater-语法","depth":2,"text":"二、docxtemplater 语法","children":[{"id":"_1-单一变量使用-包含","depth":3,"text":"1.  单一变量使用  {}  包含"},{"id":"_2-json数组格式则包裹一个循环对象","depth":3,"text":"2.  json数组格式，则包裹一个循环对象："},{"id":"_3-使用图片地址","depth":3,"text":"3.  使用图片地址："},{"id":"_4-如果多张图片地址时与循环列表一样-但必须换行","depth":3,"text":"4.  如果多张图片地址时，与循环列表一样, 但必须换行："}]},{"id":"三封装js","depth":2,"text":"三、封装JS"},{"id":"四封装vue组件","depth":2,"text":"四、封装vue组件"},{"id":"五调用方法","depth":2,"text":"五、调用方法"}]}},"_type":"markdown","_id":"content:posts:20231205.md","_source":"content","_file":"posts/20231205.md","_stem":"posts/20231205","_extension":"md"}